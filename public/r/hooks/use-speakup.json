{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-speakup",
  "type": "registry:hook",
  "title": "Use Speakup",
  "description": "Use the useSpeakup hook to convert text to speech, with options to control pitch, rate, volume, and voice selection.",
  "files": [
    {
      "path": "registry/hooks/use-speakup.tsx",
      "content": "import * as React from \"react\"\n\ndeclare global {\n  interface Window {\n    SpeechRecognition: new () => SpeechRecognition\n    webkitSpeechRecognition: new () => SpeechRecognition\n  }\n\n  class SpeechRecognition extends EventTarget {\n    lang: string\n    continuous: boolean\n    interimResults: boolean\n    maxAlternatives: number\n    onstart: (() => void) | null\n    onend: (() => void) | null\n    onerror: ((event: SpeechRecognitionErrorEvent) => void) | null\n    onresult: ((event: SpeechRecognitionEvent) => void) | null\n    start(): void\n    stop(): void\n    abort(): void\n  }\n\n  interface SpeechRecognitionErrorEvent extends Event {\n    error:\n      | \"no-speech\"\n      | \"aborted\"\n      | \"audio-capture\"\n      | \"network\"\n      | \"not-allowed\"\n      | \"service-not-allowed\"\n      | \"bad-grammar\"\n      | \"language-not-supported\"\n    message: string\n  }\n\n  interface SpeechRecognitionEvent extends Event {\n    results: SpeechRecognitionResultList\n    resultIndex: number\n  }\n\n  interface SpeechRecognitionResultList {\n    readonly length: number\n    item(index: number): SpeechRecognitionResult\n    [index: number]: SpeechRecognitionResult\n  }\n\n  interface SpeechRecognitionResult {\n    readonly isFinal: boolean\n    readonly length: number\n    item(index: number): SpeechRecognitionAlternative\n    [index: number]: SpeechRecognitionAlternative\n  }\n\n  interface SpeechRecognitionAlternative {\n    readonly transcript: string\n    readonly confidence: number\n  }\n}\n\ninterface VoiceToTextOptions {\n  lang?: string\n  continuous?: boolean\n}\n\nexport const useVoiceToText = ({\n  lang = \"en-US\",\n  continuous = true,\n}: VoiceToTextOptions = {}) => {\n  const [transcript, setTranscript] = React.useState<string>(\"\")\n  const isContinuous = React.useRef<boolean>(continuous)\n\n  const recognition = React.useMemo(() => {\n    const SpeechRecognition =\n      window.SpeechRecognition || window.webkitSpeechRecognition\n    return SpeechRecognition ? new SpeechRecognition() : null\n  }, [])\n\n  React.useEffect(() => {\n    if (recognition && lang) recognition.lang = lang\n  }, [recognition, lang])\n\n  const startListening = React.useCallback(() => {\n    if (!recognition) return\n    setTranscript(\"\")\n    recognition?.start()\n    isContinuous.current = continuous\n  }, [recognition, continuous])\n\n  const stopListening = React.useCallback(() => {\n    if (!recognition) return\n    recognition?.stop()\n    isContinuous.current = false\n  }, [recognition])\n\n  const reset = React.useCallback(() => setTranscript(\"\"), [])\n\n  React.useEffect(() => {\n    if (!recognition) return\n\n    recognition.onend = () => isContinuous.current && startListening()\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.error(`Speech recognition error: ${event.error}`)\n    }\n\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\n      setTranscript((prev) => `${prev} ${event.results[0][0].transcript}`)\n    }\n  }, [recognition, startListening])\n\n  return {\n    startListening,\n    stopListening,\n    transcript,\n    reset,\n    isSupported: !!recognition,\n  }\n}\n\nenum NodeType {\n  ELEMENT = 1,\n  TEXT = 3,\n}\n\ninterface TextToVoiceOptions {\n  pitch?: number\n  rate?: number\n  volume?: number\n}\n\nexport const useTextToVoice = <T extends HTMLElement>({\n  pitch = 1,\n  rate = 1,\n  volume = 1,\n}: TextToVoiceOptions = {}) => {\n  const textRef = React.useRef<T>(null)\n  const transcript = React.useRef<string>(\"\")\n  const [textContent, setTextContent] = React.useState<string>(\"\")\n  const [isSpeaking, setIsSpeaking] = React.useState(false)\n  const synth = typeof window !== \"undefined\" ? window.speechSynthesis : null\n\n  const utter = React.useMemo(() => {\n    if (!synth || typeof SpeechSynthesisUtterance === \"undefined\") return null\n    return new SpeechSynthesisUtterance(textContent)\n  }, [textContent, synth])\n\n  const extractText = React.useCallback((node: Node | null) => {\n    if (!node) return\n\n    node.childNodes.forEach((child) => {\n      if (child.nodeType === NodeType.TEXT) {\n        transcript.current += child.textContent\n      } else if (child.nodeType === NodeType.ELEMENT) {\n        extractText(child)\n      }\n    })\n  }, [])\n\n  React.useEffect(() => {\n    if (textRef.current) {\n      transcript.current = \"\"\n      extractText(textRef.current)\n      setTextContent(transcript.current)\n    }\n  }, [extractText])\n\n  React.useEffect(() => {\n    if (!utter) return\n\n    utter.pitch = pitch\n    utter.rate = rate\n    utter.volume = volume\n  }, [utter, pitch, rate, volume])\n\n  React.useEffect(() => {\n    if (!utter) return\n\n    utter.onend = () => setIsSpeaking(false)\n    utter.onerror = (event) => {\n      console.error(`Speech synthesis error: ${event.error}`)\n    }\n  }, [utter])\n\n  const voices = React.useMemo(() => synth?.getVoices() || [], [synth])\n  const voiceNames = React.useMemo(() => voices.map((v) => v.name), [voices])\n\n  const speak = React.useCallback(() => {\n    if (synth && utter) {\n      synth.speak(utter)\n      setIsSpeaking(true)\n    }\n  }, [synth, utter])\n\n  const pause = React.useCallback(() => {\n    synth?.pause()\n    setIsSpeaking(false)\n  }, [synth])\n\n  const resume = React.useCallback(() => {\n    synth?.resume()\n    setIsSpeaking(true)\n  }, [synth])\n\n  const setVoice = React.useCallback(\n    (name: string) => {\n      if (utter) {\n        utter.voice = voices.find((v) => v.name === name) || null\n      }\n    },\n    [utter, voices]\n  )\n\n  return {\n    ref: textRef,\n    speak,\n    pause,\n    resume,\n    setVoice,\n    voices: voiceNames,\n    isSpeaking,\n    isSupported: !!synth,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}
