{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-speakup",
  "type": "registry:hook",
  "title": "Use Speakup",
  "description": "Use the useSpeakup hook to convert text to speech, with options to control pitch, rate, volume, and voice selection.",
  "files": [
    {
      "path": "registry/hooks/use-speakup.tsx",
      "content": "import * as React from \"react\"\r\n\r\ndeclare global {\r\n  interface Window {\r\n    SpeechRecognition: new () => SpeechRecognition\r\n    webkitSpeechRecognition: new () => SpeechRecognition\r\n  }\r\n\r\n  class SpeechRecognition extends EventTarget {\r\n    lang: string\r\n    continuous: boolean\r\n    interimResults: boolean\r\n    maxAlternatives: number\r\n    onstart: (() => void) | null\r\n    onend: (() => void) | null\r\n    onerror: ((event: SpeechRecognitionErrorEvent) => void) | null\r\n    onresult: ((event: SpeechRecognitionEvent) => void) | null\r\n    start(): void\r\n    stop(): void\r\n    abort(): void\r\n    listening: boolean\r\n  }\r\n\r\n  interface SpeechRecognitionErrorEvent extends Event {\r\n    error:\r\n      | \"no-speech\"\r\n      | \"aborted\"\r\n      | \"audio-capture\"\r\n      | \"network\"\r\n      | \"not-allowed\"\r\n      | \"service-not-allowed\"\r\n      | \"bad-grammar\"\r\n      | \"language-not-supported\"\r\n    message: string\r\n  }\r\n\r\n  interface SpeechRecognitionEvent extends Event {\r\n    results: SpeechRecognitionResultList\r\n    resultIndex: number\r\n  }\r\n\r\n  interface SpeechRecognitionResultList {\r\n    readonly length: number\r\n    item(index: number): SpeechRecognitionResult\r\n    [index: number]: SpeechRecognitionResult\r\n  }\r\n\r\n  interface SpeechRecognitionResult {\r\n    readonly isFinal: boolean\r\n    readonly length: number\r\n    item(index: number): SpeechRecognitionAlternative\r\n    [index: number]: SpeechRecognitionAlternative\r\n  }\r\n\r\n  interface SpeechRecognitionAlternative {\r\n    readonly transcript: string\r\n    readonly confidence: number\r\n  }\r\n}\r\n\r\ninterface VoiceToTextOptions {\r\n  lang?: string\r\n  continuous?: boolean\r\n}\r\n\r\nexport const useVoiceToText = ({\r\n  lang = \"en-US\",\r\n  continuous = true,\r\n}: VoiceToTextOptions = {}) => {\r\n  const [transcript, setTranscript] = React.useState<string>(\"\")\r\n  const isContinuous = React.useRef<boolean>(continuous)\r\n  const [isListening, setIsListening] = React.useState(false)\r\n  const [status, setStatus] = React.useState<{\r\n    isSupported: boolean\r\n    error?: \"permission\" | \"device\" | \"api\"\r\n  }>({ isSupported: false })\r\n\r\n  React.useEffect(() => {\r\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n      setStatus({ isSupported: false, error: \"device\" })\r\n    }\r\n  }, [])\r\n\r\n  const SpeechRecognition = React.useMemo(() => {\r\n    if (typeof window === \"undefined\") {\r\n      setStatus({ isSupported: false, error: \"api\" })\r\n      return null\r\n    }\r\n    return window.SpeechRecognition || window.webkitSpeechRecognition\r\n  }, [])\r\n\r\n  const recognition = React.useMemo(() => {\r\n    if (SpeechRecognition) return new SpeechRecognition()\r\n    else return null\r\n  }, [SpeechRecognition])\r\n\r\n  React.useEffect(() => {\r\n    if (recognition && lang) recognition.lang = lang\r\n  }, [recognition, lang])\r\n\r\n  const startListening = React.useCallback(() => {\r\n    if (!recognition) return\r\n    if (recognition?.listening) return\r\n    recognition?.start()\r\n    isContinuous.current = continuous\r\n    setIsListening(true)\r\n  }, [recognition, continuous])\r\n\r\n  const stopListening = React.useCallback(() => {\r\n    if (!recognition) return\r\n    recognition?.stop()\r\n    isContinuous.current = false\r\n    setIsListening(false)\r\n  }, [recognition])\r\n\r\n  const reset = React.useCallback(() => setTranscript(\"\"), [])\r\n\r\n  React.useEffect(() => {\r\n    if (!recognition) return\r\n\r\n    recognition.onend = () => {\r\n      setIsListening(false)\r\n      if (isContinuous.current) {\r\n        startListening()\r\n      }\r\n    }\r\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\r\n      console.error(`Speech recognition error: ${event.error}`)\r\n      if (event.error === \"no-speech\") {\r\n        stopListening()\r\n      }\r\n      setIsListening(false)\r\n    }\r\n\r\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\r\n      setTranscript((prev) => `${prev} ${event.results[0][0].transcript}`)\r\n    }\r\n  }, [recognition, startListening, stopListening])\r\n\r\n  const retry = React.useCallback(async () => {\r\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n      setStatus({ isSupported: false, error: \"device\" })\r\n      return\r\n    }\r\n    await navigator.mediaDevices\r\n      .getUserMedia({ audio: true })\r\n      .then(() => {\r\n        setStatus({ isSupported: true })\r\n      })\r\n      .catch(() => {\r\n        setStatus({ isSupported: false, error: \"device\" })\r\n      })\r\n  }, [])\r\n\r\n  return {\r\n    startListening,\r\n    stopListening,\r\n    isListening,\r\n    transcript,\r\n    reset,\r\n    ...status,\r\n    retry,\r\n  }\r\n}\r\n\r\ninterface TextToVoiceOptions {\r\n  text?: string\r\n  pitch?: number\r\n  rate?: number\r\n  volume?: number\r\n}\r\n\r\nexport const useTextToVoice = ({\r\n  text = \"\",\r\n  pitch = 1,\r\n  rate = 1,\r\n  volume = 1,\r\n}: TextToVoiceOptions = {}) => {\r\n  const [isSpeaking, setIsSpeaking] = React.useState(false)\r\n  const [isPaused, setIsPaused] = React.useState(false)\r\n  const [voices, setVoices] = React.useState<SpeechSynthesisVoice[]>([])\r\n  const [selectedVoice, setSelectedVoice] =\r\n    React.useState<SpeechSynthesisVoice | null>(null)\r\n  const utteranceRef = React.useRef<SpeechSynthesisUtterance | null>(null)\r\n\r\n  const pitchRef = React.useRef(pitch)\r\n  const rateRef = React.useRef(rate)\r\n  const volumeRef = React.useRef(volume)\r\n  const selectedVoiceRef = React.useRef(selectedVoice)\r\n  const chunksRef = React.useRef<string[]>([])\r\n  const currentChunkIndexRef = React.useRef(0)\r\n\r\n  const synth = React.useMemo(() => {\r\n    if (typeof window === \"undefined\") return null\r\n    return window.speechSynthesis\r\n  }, [])\r\n\r\n  React.useEffect(() => {\r\n    pitchRef.current = pitch\r\n  }, [pitch])\r\n\r\n  React.useEffect(() => {\r\n    rateRef.current = rate\r\n  }, [rate])\r\n\r\n  React.useEffect(() => {\r\n    volumeRef.current = volume\r\n  }, [volume])\r\n\r\n  React.useEffect(() => {\r\n    selectedVoiceRef.current = selectedVoice\r\n  }, [selectedVoice])\r\n\r\n  React.useEffect(() => {\r\n    if (!synth) return\r\n\r\n    const updateVoices = () => {\r\n      const voices = synth.getVoices()\r\n      setVoices(voices)\r\n    }\r\n\r\n    updateVoices()\r\n    synth.addEventListener(\"voiceschanged\", updateVoices)\r\n    return () => synth.removeEventListener(\"voiceschanged\", updateVoices)\r\n  }, [synth])\r\n\r\n  React.useEffect(() => {\r\n    if (voices.length > 0 && !selectedVoice) {\r\n      setSelectedVoice(voices[0])\r\n    }\r\n  }, [voices, selectedVoice])\r\n\r\n  const createUtterance = React.useCallback(\r\n    (chunkText: string) => {\r\n      if (!synth) return null\r\n\r\n      const utterance = new SpeechSynthesisUtterance(chunkText)\r\n      utterance.pitch = pitchRef.current\r\n      utterance.rate = rateRef.current\r\n      utterance.volume = volumeRef.current\r\n      utterance.voice = selectedVoiceRef.current\r\n\r\n      utterance.onstart = () => {\r\n        setIsSpeaking(true)\r\n        setIsPaused(false)\r\n      }\r\n\r\n      utterance.onend = () => {\r\n        const nextIndex = currentChunkIndexRef.current + 1\r\n        if (nextIndex < chunksRef.current.length) {\r\n          currentChunkIndexRef.current = nextIndex\r\n          const nextChunk = chunksRef.current[nextIndex]\r\n          const nextUtterance = createUtterance(nextChunk)\r\n          if (nextUtterance) {\r\n            utteranceRef.current = nextUtterance\r\n            synth.speak(nextUtterance)\r\n          }\r\n        } else {\r\n          setIsSpeaking(false)\r\n          setIsPaused(false)\r\n        }\r\n      }\r\n\r\n      utterance.onerror = (event) => {\r\n        console.error(`Speech error: ${event.error}`)\r\n        setIsSpeaking(false)\r\n        setIsPaused(false)\r\n      }\r\n\r\n      utterance.onpause = () => {\r\n        setIsSpeaking(false)\r\n        setIsPaused(true)\r\n      }\r\n\r\n      utterance.onresume = () => {\r\n        setIsSpeaking(true)\r\n        setIsPaused(false)\r\n      }\r\n\r\n      return utterance\r\n    },\r\n    [synth]\r\n  )\r\n\r\n  const speak = React.useCallback(() => {\r\n    if (!synth || !text) return\r\n\r\n    synth.cancel()\r\n    const chunks = text.match(new RegExp(`.{1,${200}}`, \"g\")) || []\r\n    chunksRef.current = chunks\r\n    currentChunkIndexRef.current = 0\r\n\r\n    if (chunks.length === 0) return\r\n\r\n    const utterance = createUtterance(chunks[0] || \"\")\r\n    if (!utterance) return\r\n\r\n    utteranceRef.current = utterance\r\n    synth.speak(utterance)\r\n  }, [text, synth, createUtterance])\r\n\r\n  const pause = React.useCallback(() => {\r\n    if (synth?.speaking && utteranceRef.current) {\r\n      synth.pause()\r\n      setIsSpeaking(false)\r\n      setIsPaused(true)\r\n    }\r\n  }, [synth])\r\n\r\n  const resume = React.useCallback(() => {\r\n    if (synth?.paused && utteranceRef.current) {\r\n      synth.resume()\r\n      setIsSpeaking(true)\r\n      setIsPaused(false)\r\n    }\r\n  }, [synth])\r\n\r\n  const cancel = React.useCallback(() => {\r\n    synth?.cancel()\r\n    setIsSpeaking(false)\r\n    setIsPaused(false)\r\n  }, [synth])\r\n\r\n  const setVoice = React.useCallback(\r\n    (name: string) => {\r\n      const voice = voices.find((v) => v.name === name)\r\n      setSelectedVoice(voice || null)\r\n    },\r\n    [voices]\r\n  )\r\n\r\n  return {\r\n    speak,\r\n    pause,\r\n    resume,\r\n    cancel,\r\n    voice: selectedVoice?.name,\r\n    setVoice,\r\n    isSpeaking,\r\n    isPaused,\r\n    voices: voices.map((v) => v.name),\r\n    isSupported: !!synth,\r\n  }\r\n}\r\n",
      "type": "registry:hook"
    }
  ]
}
