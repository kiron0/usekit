{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-speakup",
  "type": "registry:hook",
  "title": "Use Speakup",
  "description": "Use the useSpeakup hook to convert text to speech, with options to control pitch, rate, volume, and voice selection.",
  "files": [
    {
      "path": "registry/hooks/use-speakup.tsx",
      "content": "import * as React from \"react\"\n\ndeclare global {\n  interface Window {\n    SpeechRecognition: new () => SpeechRecognition\n    webkitSpeechRecognition: new () => SpeechRecognition\n  }\n\n  class SpeechRecognition extends EventTarget {\n    lang: string\n    continuous: boolean\n    interimResults: boolean\n    maxAlternatives: number\n    onstart: (() => void) | null\n    onend: (() => void) | null\n    onerror: ((event: SpeechRecognitionErrorEvent) => void) | null\n    onresult: ((event: SpeechRecognitionEvent) => void) | null\n    start(): void\n    stop(): void\n    abort(): void\n    listening: boolean\n  }\n\n  interface SpeechRecognitionErrorEvent extends Event {\n    error:\n      | \"no-speech\"\n      | \"aborted\"\n      | \"audio-capture\"\n      | \"network\"\n      | \"not-allowed\"\n      | \"service-not-allowed\"\n      | \"bad-grammar\"\n      | \"language-not-supported\"\n    message: string\n  }\n\n  interface SpeechRecognitionEvent extends Event {\n    results: SpeechRecognitionResultList\n    resultIndex: number\n  }\n\n  interface SpeechRecognitionResultList {\n    readonly length: number\n    item(index: number): SpeechRecognitionResult\n    [index: number]: SpeechRecognitionResult\n  }\n\n  interface SpeechRecognitionResult {\n    readonly isFinal: boolean\n    readonly length: number\n    item(index: number): SpeechRecognitionAlternative\n    [index: number]: SpeechRecognitionAlternative\n  }\n\n  interface SpeechRecognitionAlternative {\n    readonly transcript: string\n    readonly confidence: number\n  }\n}\n\ninterface VoiceToTextOptions {\n  lang?: string\n  continuous?: boolean\n}\n\nexport const useVoiceToText = ({\n  lang = \"en-US\",\n  continuous = true,\n}: VoiceToTextOptions = {}) => {\n  const [transcript, setTranscript] = React.useState<string>(\"\")\n  const isContinuous = React.useRef<boolean>(continuous)\n  const [isListening, setIsListening] = React.useState(false)\n\n  const SpeechRecognition = React.useMemo(() => {\n    if (typeof window === \"undefined\") {\n      return null\n    }\n    return window.SpeechRecognition || window.webkitSpeechRecognition\n  }, [])\n\n  const recognition = React.useMemo(() => {\n    if (SpeechRecognition) return new SpeechRecognition()\n    else return null\n  }, [SpeechRecognition])\n\n  React.useEffect(() => {\n    if (recognition && lang) recognition.lang = lang\n  }, [recognition, lang])\n\n  const startListening = React.useCallback(() => {\n    if (!recognition) return\n    if (recognition?.listening) return\n    recognition?.start()\n    isContinuous.current = continuous\n    setIsListening(true)\n  }, [recognition, continuous])\n\n  const stopListening = React.useCallback(() => {\n    if (!recognition) return\n    recognition?.stop()\n    isContinuous.current = false\n    setIsListening(false)\n  }, [recognition])\n\n  const reset = React.useCallback(() => setTranscript(\"\"), [])\n\n  React.useEffect(() => {\n    if (!recognition) return\n\n    recognition.onend = () => {\n      setIsListening(false)\n      if (isContinuous.current) {\n        startListening()\n      }\n    }\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.error(`Speech recognition error: ${event.error}`)\n      if (event.error === \"no-speech\") {\n        stopListening()\n      }\n      setIsListening(false)\n    }\n\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\n      setTranscript((prev) => `${prev} ${event.results[0][0].transcript}`)\n    }\n  }, [recognition, startListening, stopListening])\n\n  return {\n    startListening,\n    stopListening,\n    isListening,\n    transcript,\n    reset,\n    isSupported: !!recognition,\n  }\n}\n\ninterface TextToVoiceOptions {\n  text?: string\n  pitch?: number\n  rate?: number\n  volume?: number\n  chunkSize?: number\n  onError?: (error: string) => void\n}\n\nexport const useTextToVoice = ({\n  text = \"\",\n  pitch = 1,\n  rate = 1,\n  volume = 1,\n  chunkSize = 200,\n  onError,\n}: TextToVoiceOptions = {}) => {\n  const [isSpeaking, setIsSpeaking] = React.useState(false)\n  const [isPaused, setIsPaused] = React.useState(false)\n  const [voices, setVoices] = React.useState<SpeechSynthesisVoice[]>([])\n  const [selectedVoice, setSelectedVoice] =\n    React.useState<SpeechSynthesisVoice | null>(null)\n  const utteranceRef = React.useRef<SpeechSynthesisUtterance | null>(null)\n\n  const pitchRef = React.useRef(pitch)\n  const rateRef = React.useRef(rate)\n  const volumeRef = React.useRef(volume)\n  const selectedVoiceRef = React.useRef(selectedVoice)\n  const chunksRef = React.useRef<string[]>([])\n  const currentChunkIndexRef = React.useRef(0)\n\n  const synth = React.useMemo(() => {\n    if (typeof window === \"undefined\") return null\n    return window.speechSynthesis\n  }, [])\n\n  React.useEffect(() => {\n    pitchRef.current = pitch\n  }, [pitch])\n\n  React.useEffect(() => {\n    rateRef.current = rate\n  }, [rate])\n\n  React.useEffect(() => {\n    volumeRef.current = volume\n  }, [volume])\n\n  React.useEffect(() => {\n    selectedVoiceRef.current = selectedVoice\n  }, [selectedVoice])\n\n  React.useEffect(() => {\n    if (!synth) return\n\n    const updateVoices = () => {\n      const voices = synth.getVoices()\n      setVoices(voices)\n    }\n\n    updateVoices()\n    synth.addEventListener(\"voiceschanged\", updateVoices)\n    return () => synth.removeEventListener(\"voiceschanged\", updateVoices)\n  }, [synth])\n\n  const createUtterance = React.useCallback(\n    (chunkText: string) => {\n      if (!synth) return null\n\n      const utterance = new SpeechSynthesisUtterance(chunkText)\n      utterance.pitch = pitchRef.current\n      utterance.rate = rateRef.current\n      utterance.volume = volumeRef.current\n      utterance.voice = selectedVoiceRef.current\n\n      utterance.onstart = () => {\n        setIsSpeaking(true)\n        setIsPaused(false)\n      }\n\n      utterance.onend = () => {\n        const nextIndex = currentChunkIndexRef.current + 1\n        if (nextIndex < chunksRef.current.length) {\n          currentChunkIndexRef.current = nextIndex\n          const nextChunk = chunksRef.current[nextIndex]\n          const nextUtterance = createUtterance(nextChunk)\n          if (nextUtterance) {\n            utteranceRef.current = nextUtterance\n            synth.speak(nextUtterance)\n          }\n        } else {\n          setIsSpeaking(false)\n          setIsPaused(false)\n        }\n      }\n\n      utterance.onerror = (event) => {\n        onError?.(`Speech error: ${event.error}`)\n        setIsSpeaking(false)\n        setIsPaused(false)\n      }\n\n      utterance.onpause = () => {\n        setIsSpeaking(false)\n        setIsPaused(true)\n      }\n\n      utterance.onresume = () => {\n        setIsSpeaking(true)\n        setIsPaused(false)\n      }\n\n      return utterance\n    },\n    [synth, onError]\n  )\n\n  const speak = React.useCallback(() => {\n    if (!synth || !text) return\n\n    synth.cancel()\n    const chunks = text.match(new RegExp(`.{1,${chunkSize}}`, \"g\")) || []\n    chunksRef.current = chunks\n    currentChunkIndexRef.current = 0\n\n    if (chunks.length === 0) return\n\n    const utterance = createUtterance(chunks[0] || \"\")\n    if (!utterance) return\n\n    utteranceRef.current = utterance\n    synth.speak(utterance)\n  }, [text, synth, createUtterance, chunkSize])\n\n  const pause = React.useCallback(() => {\n    if (synth?.speaking && utteranceRef.current) {\n      synth.pause()\n      setIsSpeaking(false)\n      setIsPaused(true)\n    }\n  }, [synth])\n\n  const resume = React.useCallback(() => {\n    if (synth?.paused && utteranceRef.current) {\n      synth.resume()\n      setIsSpeaking(true)\n      setIsPaused(false)\n    }\n  }, [synth])\n\n  const cancel = React.useCallback(() => {\n    synth?.cancel()\n    setIsSpeaking(false)\n    setIsPaused(false)\n  }, [synth])\n\n  const setVoice = React.useCallback(\n    (name: string) => {\n      const voice = voices.find((v) => v.name === name)\n      setSelectedVoice(voice || null)\n    },\n    [voices]\n  )\n\n  return {\n    speak,\n    pause,\n    resume,\n    cancel,\n    voice: selectedVoice?.name,\n    setVoice,\n    isSpeaking,\n    isPaused,\n    voices: voices.map((v) => v.name),\n    isSupported: !!synth,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}
