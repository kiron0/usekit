{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-scramble",
  "type": "registry:hook",
  "title": "Use Scramble",
  "description": "Scramble text with the useScramble hook, providing methods to scramble, unscramble, and toggle between them.",
  "files": [
    {
      "path": "registry/hooks/use-scramble.tsx",
      "content": "import { useEffect, useRef } from \"react\"\n\nfunction getRandomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nfunction getRandomChar(range: RangeOrCharCodes) {\n  let rand = 0\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1])\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)]\n  }\n  return String.fromCodePoint(rand)\n}\n\ntype RangeOrCharCodes = { 0: number; 1: number } & number[]\n\nexport type UseScrambleProps = {\n  playOnMount?: boolean\n  text?: string\n  speed?: number\n  tick?: number\n  step?: number\n  chance?: number\n  seed?: number\n  scramble?: number\n  ignore?: string[]\n  range?: RangeOrCharCodes\n  overdrive?: boolean | number\n  overflow?: boolean\n  onAnimationStart?: () => void\n  onAnimationEnd?: () => void\n  onAnimationFrame?: (result: string) => void\n}\n\n/* eslint-disable prefer-const */\nexport function useScramble(props: UseScrambleProps) {\n  let {\n    playOnMount = true,\n    text = \"\",\n    speed = 1,\n    seed = 1,\n    step = 1,\n    tick = 1,\n    scramble = 1,\n    chance = 1,\n    overflow = true,\n    range = [65, 125],\n    overdrive = true,\n    onAnimationStart,\n    onAnimationFrame,\n    onAnimationEnd,\n    ignore = [\" \"],\n  } = props\n\n  const prefersReducedMotion =\n    typeof window !== \"undefined\"\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      : false\n\n  if (prefersReducedMotion) {\n    step = text.length\n    chance = 0\n    overdrive = false\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  const nodeRef = useRef<any>(null)\n  const rafRef = useRef<number>(0)\n  const elapsedRef = useRef(0)\n  const fpsInterval = 1000 / (60 * speed)\n  const stepRef = useRef<number>(0)\n  const scrambleIndexRef = useRef<number>(0)\n  const controlRef = useRef<Array<string | number | null>>([])\n  const overdriveRef = useRef<number>(0)\n\n  const setIfNotIgnored = (\n    value: string | number | null,\n    replace: string | number | null\n  ) => (ignore.includes(`${value}`) ? value : replace)\n\n  const seedForward = () => {\n    if (scrambleIndexRef.current === text.length) return\n    for (let i = 0; i < seed; i++) {\n      const index = getRandomInt(\n        scrambleIndexRef.current,\n        controlRef.current.length\n      )\n      if (\n        typeof controlRef.current[index] !== \"number\" &&\n        typeof controlRef.current[index] !== \"undefined\"\n      ) {\n        controlRef.current[index] = setIfNotIgnored(\n          controlRef.current[index],\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\n        )\n      }\n    }\n  }\n\n  const stepForward = () => {\n    for (let i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        const currentIndex = scrambleIndexRef.current\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10\n        controlRef.current[currentIndex] = setIfNotIgnored(\n          text[scrambleIndexRef.current],\n          shouldScramble\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\n            : 0\n        )\n        scrambleIndexRef.current++\n      }\n    }\n  }\n\n  const resizeControl = () => {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop()\n      controlRef.current.splice(text.length, step)\n    }\n    for (let i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\n        )\n      }\n    }\n  }\n\n  const onOverdrive = () => {\n    if (!overdrive) return\n    for (let i = 0; i < step; i++) {\n      const max = Math.max(controlRef.current.length, text.length)\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\n          text[overdriveRef.current],\n          String.fromCharCode(typeof overdrive === \"boolean\" ? 95 : overdrive)\n        )\n        overdriveRef.current++\n      }\n    }\n  }\n\n  const onTick = () => {\n    stepForward()\n    resizeControl()\n    seedForward()\n  }\n\n  /* eslint-disable react-hooks/exhaustive-deps */\n  const animate = (time: number) => {\n    if (!speed) return\n    rafRef.current = requestAnimationFrame(animate)\n    onOverdrive()\n    const timeElapsed = time - elapsedRef.current\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time\n      if (stepRef.current % tick === 0) {\n        onTick()\n      }\n      draw()\n    }\n  }\n\n  const draw = () => {\n    if (!nodeRef.current) return\n    let result = \"\"\n    for (let i = 0; i < controlRef.current.length; i++) {\n      const controlValue = controlRef.current[i]\n      switch (true) {\n        case typeof controlValue === \"number\" && controlValue > 0:\n          result += getRandomChar(range)\n          if (i <= scrambleIndexRef.current) {\n            controlRef.current[i] = (controlRef.current[i] as number) - 1\n          }\n          break\n        case typeof controlValue === \"string\" &&\n          (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue\n          break\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i]\n          break\n        case controlValue === 0 && i < text.length:\n          result += text[i]\n          controlRef.current[i] = text[i]\n          break\n        default:\n          result += \"\"\n      }\n    }\n    nodeRef.current.innerHTML = result\n    onAnimationFrame && onAnimationFrame(result)\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length)\n      onAnimationEnd && onAnimationEnd()\n      cancelAnimationFrame(rafRef.current)\n    }\n    stepRef.current++\n  }\n\n  const reset = () => {\n    stepRef.current = 0\n    scrambleIndexRef.current = 0\n    overdriveRef.current = 0\n    if (!overflow) {\n      controlRef.current = new Array(text.length)\n    }\n  }\n\n  const play = () => {\n    cancelAnimationFrame(rafRef.current)\n    reset()\n    onAnimationStart && onAnimationStart()\n    rafRef.current = requestAnimationFrame(animate)\n  }\n\n  useEffect(() => {\n    reset()\n  }, [text])\n\n  useEffect(() => {\n    cancelAnimationFrame(rafRef.current)\n    rafRef.current = requestAnimationFrame(animate)\n    return () => {\n      cancelAnimationFrame(rafRef.current)\n    }\n  }, [animate])\n\n  useEffect(() => {\n    if (!playOnMount) {\n      controlRef.current = text.split(\"\")\n      stepRef.current = text.length\n      scrambleIndexRef.current = text.length\n      overdriveRef.current = text.length\n      draw()\n      cancelAnimationFrame(rafRef.current)\n    }\n  }, [])\n\n  return { ref: nodeRef, replay: play }\n}\n",
      "type": "registry:hook"
    }
  ]
}
