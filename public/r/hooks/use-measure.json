{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-measure",
  "type": "registry:hook",
  "title": "Use Measure",
  "description": "Measure the dimensions of an element with useMeasure, providing options to track changes and observe the element.",
  "dependencies": ["lucide-react"],
  "files": [
    {
      "path": "registry/hooks/use-measure.tsx",
      "content": "import * as React from \"react\"\r\nimport { Copy, RefreshCw } from \"lucide-react\"\r\nimport * as ReactDOM from \"react-dom\"\r\n\r\ntype Point = { x: number; y: number } | null\r\n\r\nconst convertPxTo = (px: number, unit: \"cm\" | \"rem\" | \"inches\") => {\r\n  const rem = px / 16\r\n  const inches = px / 96\r\n  const cm = inches * 2.54\r\n\r\n  return { cm, rem, inches }[unit]\r\n}\r\n\r\nconst MOBILE_BREAKPOINT = 768\r\n\r\ninterface MeasureOptions {\r\n  borderRadius?: number\r\n  borderWidth?: number\r\n  actionPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\r\n  measurementPosition?:\r\n    | \"top-left\"\r\n    | \"top-right\"\r\n    | \"bottom-left\"\r\n    | \"bottom-right\"\r\n  startMeasure?: boolean\r\n  ref?: React.RefObject<HTMLDivElement | null>\r\n}\r\n\r\nconst actionPositions = [\r\n  { name: \"top-right\", top: 100, right: 16 },\r\n  { name: \"top-left\", top: 100, left: 16 },\r\n  { name: \"bottom-right\", bottom: 100, right: 16 },\r\n  { name: \"bottom-left\", bottom: 100, left: 16 },\r\n]\r\n\r\nconst measurementPositions = [\r\n  { name: \"top-right\", top: 16, right: 16 },\r\n  { name: \"top-left\", top: 16, left: 16 },\r\n  { name: \"bottom-right\", bottom: 16, right: 16 },\r\n  { name: \"bottom-left\", bottom: 16, left: 16 },\r\n]\r\n\r\nexport function useMeasure({\r\n  borderRadius = 0.5,\r\n  borderWidth = 1,\r\n  actionPosition = \"top-right\",\r\n  measurementPosition = \"bottom-left\",\r\n  startMeasure = false,\r\n  ref,\r\n}: MeasureOptions) {\r\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\r\n\r\n  const [startPoint, setStartPoint] = React.useState<Point>(null)\r\n  const [endPoint, setEndPoint] = React.useState<Point>(null)\r\n  const [isMeasuring, setMeasuring] = React.useState(false)\r\n  const [isDragging, setDragging] = React.useState(false)\r\n  const [dragOffset, setDragOffset] = React.useState<{\r\n    x: number\r\n    y: number\r\n  } | null>(null)\r\n  const [resizeCorner, setResizeCorner] = React.useState<string | null>(null)\r\n  const borderBoxRef = React.useRef<HTMLDivElement>(null)\r\n\r\n  const originalStartRef = React.useRef<Point>(null)\r\n  const originalEndRef = React.useRef<Point>(null)\r\n  const initialMouseRef = React.useRef<{ x: number; y: number } | null>(null)\r\n\r\n  const getBoundingRect = React.useCallback(() => {\r\n    if (ref?.current) {\r\n      return ref.current.getBoundingClientRect()\r\n    }\r\n    return {\r\n      left: 0,\r\n      top: 0,\r\n      right: window.innerWidth,\r\n      bottom: window.innerHeight,\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }, [ref])\r\n\r\n  const isMouseOverCorner = (\r\n    mouseX: number,\r\n    mouseY: number,\r\n    left: number,\r\n    top: number,\r\n    width: number,\r\n    height: number,\r\n    threshold = 8\r\n  ) => {\r\n    const corners = [\r\n      { name: \"top-left\", x: left, y: top },\r\n      { name: \"top-right\", x: left + width, y: top },\r\n      { name: \"bottom-left\", x: left, y: top + height },\r\n      { name: \"bottom-right\", x: left + width, y: top + height },\r\n    ]\r\n\r\n    for (const corner of corners) {\r\n      const dx = Math.abs(mouseX - corner.x)\r\n      const dy = Math.abs(mouseY - corner.y)\r\n      if (dx < threshold && dy < threshold) return corner.name\r\n    }\r\n    return null\r\n  }\r\n\r\n  const handleMouseDown = React.useCallback(\r\n    (e: MouseEvent) => {\r\n      e.preventDefault()\r\n\r\n      if (ref?.current && !startMeasure) return\r\n\r\n      const rect = getBoundingRect()\r\n      const x = e.clientX - rect.left\r\n      const y = e.clientY - rect.top\r\n\r\n      if (ref?.current && !ref.current.contains(e.target as Node)) {\r\n        return\r\n      }\r\n\r\n      if (!startPoint || !endPoint) {\r\n        setStartPoint({ x, y })\r\n        setEndPoint({ x, y })\r\n        setMeasuring(true)\r\n        return\r\n      }\r\n\r\n      const left = Math.min(startPoint.x, endPoint.x)\r\n      const top = Math.min(startPoint.y, endPoint.y)\r\n      const width = Math.abs(endPoint.x - startPoint.x)\r\n      const height = Math.abs(endPoint.y - startPoint.y)\r\n\r\n      const corner = isMouseOverCorner(x, y, left, top, width, height)\r\n      if (corner) {\r\n        originalStartRef.current = startPoint\r\n        originalEndRef.current = endPoint\r\n        initialMouseRef.current = { x, y }\r\n        setResizeCorner(corner)\r\n      } else if (\r\n        x >= left &&\r\n        x <= left + width &&\r\n        y >= top &&\r\n        y <= top + height\r\n      ) {\r\n        setDragging(true)\r\n        setDragOffset({ x: x - left, y: y - top })\r\n      }\r\n    },\r\n    [startPoint, endPoint, getBoundingRect, ref, startMeasure]\r\n  )\r\n\r\n  const handleMouseMove = React.useCallback(\r\n    (e: MouseEvent) => {\r\n      if (ref?.current && !startMeasure) return\r\n\r\n      const rect = getBoundingRect()\r\n      const x = e.clientX - rect.left\r\n      const y = e.clientY - rect.top\r\n\r\n      if (isMeasuring) {\r\n        const constrainedX = Math.max(0, Math.min(x, rect.width))\r\n        const constrainedY = Math.max(0, Math.min(y, rect.height))\r\n        setEndPoint({ x: constrainedX, y: constrainedY })\r\n        return\r\n      }\r\n\r\n      if (\r\n        resizeCorner &&\r\n        originalStartRef.current &&\r\n        originalEndRef.current &&\r\n        initialMouseRef.current\r\n      ) {\r\n        const deltaX = x - initialMouseRef.current.x\r\n        const deltaY = y - initialMouseRef.current.y\r\n\r\n        const newStart = { ...originalStartRef.current }\r\n        const newEnd = { ...originalEndRef.current }\r\n\r\n        switch (resizeCorner) {\r\n          case \"top-left\":\r\n            newStart.x = Math.max(\r\n              0,\r\n              Math.min(newStart.x + deltaX, newEnd.x - 10)\r\n            )\r\n            newStart.y = Math.max(\r\n              0,\r\n              Math.min(newStart.y + deltaY, newEnd.y - 10)\r\n            )\r\n            break\r\n          case \"top-right\":\r\n            newEnd.x = Math.min(\r\n              getBoundingRect().width,\r\n              Math.max(newEnd.x + deltaX, newStart.x + 10)\r\n            )\r\n            newStart.y = Math.max(\r\n              0,\r\n              Math.min(newStart.y + deltaY, newEnd.y - 10)\r\n            )\r\n            break\r\n          case \"bottom-right\":\r\n            newEnd.x = Math.min(\r\n              getBoundingRect().width,\r\n              Math.max(newEnd.x + deltaX, newStart.x + 10)\r\n            )\r\n            newEnd.y = Math.min(\r\n              getBoundingRect().height,\r\n              Math.max(newEnd.y + deltaY, newStart.y + 10)\r\n            )\r\n            break\r\n          case \"bottom-left\":\r\n            newStart.x = Math.max(\r\n              0,\r\n              Math.min(newStart.x + deltaX, newEnd.x - 10)\r\n            )\r\n            newEnd.y = Math.min(\r\n              getBoundingRect().height,\r\n              Math.max(newEnd.y + deltaY, newStart.y + 10)\r\n            )\r\n            break\r\n          default:\r\n            break\r\n        }\r\n\r\n        if (newStart.x < newEnd.x && newStart.y < newEnd.y) {\r\n          setStartPoint(newStart)\r\n          setEndPoint(newEnd)\r\n        }\r\n      } else if (isDragging && dragOffset && startPoint && endPoint) {\r\n        const width = Math.abs(endPoint.x - startPoint.x)\r\n        const height = Math.abs(endPoint.y - startPoint.y)\r\n\r\n        const newLeft = Math.max(\r\n          0,\r\n          Math.min(x - dragOffset.x, getBoundingRect().width - width)\r\n        )\r\n        const newTop = Math.max(\r\n          0,\r\n          Math.min(y - dragOffset.y, getBoundingRect().height - height)\r\n        )\r\n\r\n        setStartPoint({ x: newLeft, y: newTop })\r\n        setEndPoint({ x: newLeft + width, y: newTop + height })\r\n      }\r\n    },\r\n    [\r\n      isMeasuring,\r\n      resizeCorner,\r\n      initialMouseRef,\r\n      startPoint,\r\n      endPoint,\r\n      dragOffset,\r\n      isDragging,\r\n      getBoundingRect,\r\n      ref,\r\n      startMeasure,\r\n    ]\r\n  )\r\n\r\n  const handleMouseUp = React.useCallback(() => {\r\n    setMeasuring(false)\r\n    setDragging(false)\r\n    setResizeCorner(null)\r\n    initialMouseRef.current = null\r\n    originalStartRef.current = null\r\n    originalEndRef.current = null\r\n  }, [])\r\n\r\n  React.useEffect(() => {\r\n    document.addEventListener(\"mousedown\", handleMouseDown)\r\n    document.addEventListener(\"mousemove\", handleMouseMove)\r\n    document.addEventListener(\"mouseup\", handleMouseUp)\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mousedown\", handleMouseDown)\r\n      document.removeEventListener(\"mousemove\", handleMouseMove)\r\n      document.removeEventListener(\"mouseup\", handleMouseUp)\r\n    }\r\n  }, [handleMouseDown, handleMouseMove, handleMouseUp])\r\n\r\n  React.useEffect(() => {\r\n    if (typeof window !== \"undefined\") {\r\n      const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\r\n      const onChange = () => {\r\n        setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n      }\r\n      mql.addEventListener(\"change\", onChange)\r\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n      return () => mql.removeEventListener(\"change\", onChange)\r\n    }\r\n  }, [])\r\n\r\n  const measurements = React.useMemo(() => {\r\n    if (!startPoint || !endPoint) return null\r\n\r\n    const widthPx = Math.abs(endPoint.x - startPoint.x)\r\n    const heightPx = Math.abs(endPoint.y - startPoint.y)\r\n\r\n    return {\r\n      width: {\r\n        px: widthPx,\r\n        cm: convertPxTo(widthPx, \"cm\"),\r\n        rem: convertPxTo(widthPx, \"rem\"),\r\n        inches: convertPxTo(widthPx, \"inches\"),\r\n      },\r\n      height: {\r\n        px: heightPx,\r\n        cm: convertPxTo(heightPx, \"cm\"),\r\n        rem: convertPxTo(heightPx, \"rem\"),\r\n        inches: convertPxTo(heightPx, \"inches\"),\r\n      },\r\n    }\r\n  }, [startPoint, endPoint])\r\n\r\n  const MeasureComponent = () => {\r\n    React.useEffect(() => {\r\n      const borderBox = borderBoxRef.current\r\n      if (!borderBox || !startPoint || !endPoint) return\r\n\r\n      const handleMouseMove = (e: MouseEvent) => {\r\n        const rect = borderBox.getBoundingClientRect()\r\n        const mouseX = e.clientX - rect.left\r\n        const mouseY = e.clientY - rect.top\r\n        const threshold = 8\r\n\r\n        const corners = [\r\n          { name: \"top-left\", x: 0, y: 0 },\r\n          { name: \"top-right\", x: rect.width, y: 0 },\r\n          { name: \"bottom-left\", x: 0, y: rect.height },\r\n          { name: \"bottom-right\", x: rect.width, y: rect.height },\r\n        ]\r\n\r\n        let cursor = \"move\"\r\n        for (const corner of corners) {\r\n          const dx = Math.abs(mouseX - corner.x)\r\n          const dy = Math.abs(mouseY - corner.y)\r\n          if (dx < threshold && dy < threshold) {\r\n            if (corner.name === \"top-left\" || corner.name === \"bottom-right\") {\r\n              cursor = \"nwse-resize\"\r\n            } else if (\r\n              corner.name === \"top-right\" ||\r\n              corner.name === \"bottom-left\"\r\n            ) {\r\n              cursor = \"nesw-resize\"\r\n            }\r\n            break\r\n          }\r\n        }\r\n\r\n        borderBox.style.cursor = cursor\r\n      }\r\n\r\n      borderBox.addEventListener(\"mousemove\", handleMouseMove)\r\n      return () => borderBox.removeEventListener(\"mousemove\", handleMouseMove)\r\n    }, [])\r\n\r\n    if (!startPoint || !endPoint || (ref?.current && !startMeasure) || isMobile)\r\n      return null\r\n\r\n    const rect = getBoundingRect()\r\n    const left = Math.min(startPoint.x, endPoint.x) + rect.left\r\n    const top = Math.min(startPoint.y, endPoint.y) + rect.top\r\n    const width = Math.abs(endPoint.x - startPoint.x)\r\n    const height = Math.abs(endPoint.y - startPoint.y)\r\n\r\n    const handleReset = () => {\r\n      setStartPoint(null)\r\n      setEndPoint(null)\r\n    }\r\n\r\n    const handleCopy = async () => {\r\n      if (measurements) {\r\n        const text = `Width: ${measurements.width.px.toFixed(1)}px, Height: ${measurements.height.px.toFixed(1)}px`\r\n        await navigator.clipboard.writeText(text)\r\n      }\r\n    }\r\n\r\n    return ReactDOM.createPortal(\r\n      <>\r\n        <div\r\n          ref={borderBoxRef}\r\n          style={{\r\n            position: \"fixed\",\r\n            left,\r\n            top,\r\n            width,\r\n            height,\r\n            borderRadius: `${borderRadius}px`,\r\n            borderWidth: `${borderWidth}px`,\r\n          }}\r\n          className=\"border-primary fixed z-[998] border border-dashed bg-transparent\"\r\n        />\r\n        <div\r\n          style={{\r\n            ...measurementPositions.find(\r\n              (pos) => pos.name === measurementPosition\r\n            ),\r\n          }}\r\n          className=\"bg-background/50 backdrop-blur z-[999] pointer-events-none fixed rounded-md border p-4 text-sm\"\r\n        >\r\n          <div className=\"flex flex-col gap-1\">\r\n            <span>\r\n              Width: {measurements?.width.px?.toFixed(0)} px (\r\n              {measurements?.width.cm?.toFixed(1)} cm,{\" \"}\r\n              {measurements?.width.rem?.toFixed(1)} rem,{\" \"}\r\n              {measurements?.width.inches?.toFixed(1)} inches)\r\n            </span>\r\n            <span>\r\n              Height: {measurements?.height.px?.toFixed(0)} px (\r\n              {measurements?.height.cm?.toFixed(1)} cm,{\" \"}\r\n              {measurements?.height.rem?.toFixed(1)} rem,{\" \"}\r\n              {measurements?.height.inches?.toFixed(1)} inches)\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        <div\r\n          style={{\r\n            ...actionPositions.find((pos) => pos.name === actionPosition),\r\n          }}\r\n          className=\"fixed z-[999] flex gap-2\"\r\n        >\r\n          <button\r\n            className=\"h-8 rounded-md px-3 text-xs bg-primary text-primary-foreground\"\r\n            onClick={handleReset}\r\n          >\r\n            <RefreshCw size={16} />\r\n          </button>\r\n          <button\r\n            className=\"h-8 rounded-md px-3 text-xs bg-primary text-primary-foreground\"\r\n            onClick={handleCopy}\r\n          >\r\n            <Copy size={16} />\r\n          </button>\r\n        </div>\r\n      </>,\r\n      ref?.current || document.body\r\n    )\r\n  }\r\n\r\n  if (isMobile || (ref?.current && !startMeasure)) {\r\n    return { measurements: {}, MeasureComponent: () => null, reset: () => {} }\r\n  } else {\r\n    return {\r\n      measurements,\r\n      MeasureComponent,\r\n      reset: () => {\r\n        setStartPoint(null)\r\n        setEndPoint(null)\r\n      },\r\n    }\r\n  }\r\n}\r\n",
      "type": "registry:hook"
    }
  ]
}
