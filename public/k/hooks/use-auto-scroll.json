{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-auto-scroll",
  "type": "registry:hook",
  "title": "Use Auto Scroll",
  "description": "Use the useAutoScroll hook to automatically scroll an element into view when it is focused, with optional parameters for behavior and block alignment.",
  "files": [
    {
      "path": "registry/hooks/use-auto-scroll.ts",
      "content": "import * as React from \"react\"\n\ntype ScrollableElement = HTMLUListElement | HTMLDivElement | HTMLOListElement\n\ninterface AutoScrollOptions {\n  scrollThreshold?: number\n  smoothScroll?: boolean\n}\n\nexport function useAutoScroll<T extends ScrollableElement = HTMLUListElement>(\n  enabled: boolean,\n  deps: React.DependencyList,\n  options?: AutoScrollOptions\n): React.RefObject<T | null> {\n  const listRef = React.useRef<T | null>(null)\n  const optionsRef = React.useRef(options)\n  const cleanupRef = React.useRef<(() => void) | undefined>(undefined)\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  }, [options])\n\n  React.useEffect(() => {\n    if (enabled && listRef.current) {\n      cleanupRef.current = autoScrollElement(\n        listRef.current,\n        optionsRef.current\n      )\n      return () => cleanupRef.current?.()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [enabled, ...deps])\n\n  return listRef\n}\n\nfunction autoScrollElement(\n  element: ScrollableElement,\n  options?: AutoScrollOptions\n): () => void {\n  const { scrollThreshold = 0.5, smoothScroll = true } = options || {}\n\n  let shouldAutoScroll = true\n  let touchStartY = 0\n  let lastScrollTop = 0\n  let animationFrameId: number | null = null\n\n  const checkScrollPosition = () => {\n    const { scrollHeight, clientHeight, scrollTop } = element\n    const maxScrollHeight = scrollHeight - clientHeight\n    const thresholdPosition = maxScrollHeight * (1 - scrollThreshold)\n\n    if (scrollTop < lastScrollTop) {\n      shouldAutoScroll = false\n    } else if (maxScrollHeight - scrollTop <= thresholdPosition) {\n      shouldAutoScroll = true\n    }\n\n    lastScrollTop = scrollTop\n  }\n\n  const handleWheel = (e: WheelEvent) => {\n    if (e.deltaY < 0) {\n      shouldAutoScroll = false\n    } else {\n      checkScrollPosition()\n    }\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    touchStartY = e.touches[0].clientY\n  }\n\n  const handleTouchMove = (e: TouchEvent) => {\n    const touchEndY = e.touches[0].clientY\n    const deltaY = touchStartY - touchEndY\n\n    if (deltaY < 0) {\n      shouldAutoScroll = false\n    } else {\n      checkScrollPosition()\n    }\n\n    touchStartY = touchEndY\n  }\n\n  const scrollToBottom = () => {\n    if (animationFrameId) {\n      cancelAnimationFrame(animationFrameId)\n    }\n    animationFrameId = requestAnimationFrame(() => {\n      element.scrollTo({\n        top: element.scrollHeight,\n        behavior: smoothScroll ? \"smooth\" : \"auto\",\n      })\n    })\n  }\n\n  const handleMutation = () => {\n    if (shouldAutoScroll) {\n      scrollToBottom()\n    }\n  }\n\n  const htmlElement = element as HTMLElement\n\n  htmlElement.addEventListener(\"wheel\", handleWheel)\n  htmlElement.addEventListener(\"touchstart\", handleTouchStart)\n  htmlElement.addEventListener(\"touchmove\", handleTouchMove)\n\n  const observer = new MutationObserver(handleMutation)\n  observer.observe(element, {\n    childList: true,\n    subtree: true,\n    characterData: true,\n  })\n\n  return () => {\n    observer.disconnect()\n    htmlElement.removeEventListener(\"wheel\", handleWheel)\n    htmlElement.removeEventListener(\"touchstart\", handleTouchStart)\n    htmlElement.removeEventListener(\"touchmove\", handleTouchMove)\n    if (animationFrameId) {\n      cancelAnimationFrame(animationFrameId)\n    }\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}
