{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-query-state",
  "type": "registry:hook",
  "title": "Use Query State",
  "description": "Manage query parameters in the URL with the useQueryState hook, providing methods to get, set, and remove query parameters.",
  "files": [
    {
      "path": "registry/hooks/use-query-state.ts",
      "content": "import * as React from \"react\"\nimport * as NextNavigation from \"next/navigation\"\n\ntype ParamRecord<T extends string> = Record<T, string>\nexport type ValidatorFn<V> = (value: string) => V | null\nexport type Validators<\n  T extends string,\n  V extends Record<T, unknown>,\n> = Partial<{ [K in T]: ValidatorFn<V[K]> }>\n\nexport function useQueryState<\n  T extends string,\n  V extends Record<T, unknown> = Record<T, string>,\n>(\n  paramNames: T[],\n  config: {\n    defaults?: Partial<ParamRecord<T>>\n    validators?: Validators<T, V> // Fixed from Validators<T, any>\n    normalizeEmpty?: boolean\n    suspense?: boolean\n  } = {}\n) {\n  const {\n    defaults = {} as Partial<ParamRecord<T>>,\n    validators = {} as Validators<T, V>,\n    normalizeEmpty = false,\n    suspense = false,\n  } = config\n\n  const searchParams = NextNavigation.useSearchParams()\n  const router = NextNavigation.useRouter()\n  const pathname = NextNavigation.usePathname()\n  const [isPending, startTransition] = React.useTransition()\n\n  const memoizedValidators = React.useMemo<Validators<T, V>>(\n    () => validators,\n    [validators]\n  )\n\n  const state = React.useMemo(() => {\n    const result = {} as ParamRecord<T>\n    const errors: Partial<Record<T, string>> = {}\n\n    paramNames.forEach((key) => {\n      const rawValue = searchParams.get(key)\n      const defaultValue = defaults[key]\n\n      const validator = memoizedValidators[key]\n      if (validator && rawValue !== null) {\n        try {\n          const validatedValue = validator(rawValue)\n          if (validatedValue !== null) {\n            result[key] = String(validatedValue)\n          } else {\n            errors[key] = `Invalid value for ${key}`\n            result[key] = defaultValue ?? \"\"\n          }\n        } catch (error) {\n          errors[key] =\n            error instanceof Error\n              ? error.message\n              : `Validation failed for ${key}`\n          result[key] = defaultValue ?? \"\"\n        }\n      } else {\n        result[key] = rawValue !== null ? rawValue : (defaultValue ?? \"\")\n      }\n    })\n\n    return { values: result, errors, hasErrors: Object.keys(errors).length > 0 }\n  }, [searchParams, defaults, paramNames, memoizedValidators])\n\n  const setState = React.useCallback(\n    (\n      updates: Partial<Record<T, string | null | undefined>>, // Fixed from Record<string, ...>\n      options: { replace?: boolean; skipTransition?: boolean } = {}\n    ) => {\n      const { replace = false, skipTransition = false } = options\n      const params = new URLSearchParams(searchParams.toString())\n\n      Object.entries(updates).forEach(([key, val]) => {\n        if (val == null || (normalizeEmpty && val === \"\")) {\n          params.delete(key)\n        } else {\n          params.set(key, String(val))\n        }\n      })\n\n      const queries = params.toString()\n      const url = pathname + (queries ? `?${queries}` : \"\")\n\n      const updateFn = () => router[replace ? \"replace\" : \"push\"](url)\n\n      if (suspense && !skipTransition) {\n        startTransition(updateFn)\n      } else {\n        updateFn()\n      }\n    },\n    [searchParams, pathname, router, normalizeEmpty, suspense]\n  )\n\n  const deleteState = React.useCallback(\n    (key: T, options?: { replace?: boolean; skipTransition?: boolean }) =>\n      setState(\n        { [key as T]: null } as Partial<Record<T, string | null | undefined>>,\n        options\n      ),\n    [setState]\n  )\n\n  const batchUpdate = React.useCallback(\n    (\n      updates: Partial<Record<T, string | null | undefined>>,\n      options?: { replace?: boolean; skipTransition?: boolean }\n    ) => {\n      const updateEntries = Object.entries(updates).filter(([key]) =>\n        paramNames.includes(key as T)\n      )\n      if (updateEntries.length > 0) {\n        setState(\n          Object.fromEntries(updateEntries) as Partial<\n            Record<T, string | null | undefined>\n          >,\n          options\n        )\n      }\n    },\n    [paramNames, setState]\n  )\n\n  return {\n    ...state,\n    isPending,\n    setState,\n    deleteState,\n    batchUpdate,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}
