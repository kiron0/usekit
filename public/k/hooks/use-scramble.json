{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-scramble",
  "type": "registry:hook",
  "title": "Use Scramble",
  "description": "Scramble text with the useScramble hook, providing methods to scramble, unscramble, and toggle between them.",
  "files": [
    {
      "path": "registry/hooks/use-scramble.ts",
      "content": "import * as React from \"react\"\r\n\r\nfunction getRandomInt(min: number, max: number) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min\r\n}\r\n\r\nfunction getRandomChar(range: RangeOrCharCodes) {\r\n  let rand = 0\r\n  if (range.length === 2) {\r\n    rand = getRandomInt(range[0], range[1])\r\n  } else {\r\n    rand = range[getRandomInt(0, range.length - 1)]\r\n  }\r\n  return String.fromCodePoint(rand)\r\n}\r\n\r\ntype RangeOrCharCodes = { 0: number; 1: number } & number[]\r\n\r\nexport interface UseScrambleProps {\r\n  playOnMount?: boolean\r\n  text?: string\r\n  speed?: number\r\n  tick?: number\r\n  step?: number\r\n  chance?: number\r\n  seed?: number\r\n  scramble?: number\r\n  ignore?: string[]\r\n  range?: RangeOrCharCodes\r\n  overdrive?: boolean | number\r\n  overflow?: boolean\r\n  onAnimationStart?: () => void\r\n  onAnimationEnd?: () => void\r\n  onAnimationFrame?: (result: string) => void\r\n}\r\n\r\n/* eslint-disable prefer-const */\r\nexport function useScramble(props: UseScrambleProps) {\r\n  let {\r\n    playOnMount = true,\r\n    text = \"\",\r\n    speed = 1,\r\n    seed = 1,\r\n    step = 1,\r\n    tick = 1,\r\n    scramble = 1,\r\n    chance = 1,\r\n    overflow = true,\r\n    range = [65, 125],\r\n    overdrive = true,\r\n    onAnimationStart,\r\n    onAnimationFrame,\r\n    onAnimationEnd,\r\n    ignore = [\" \"],\r\n  } = props\r\n\r\n  const prefersReducedMotion =\r\n    typeof window !== \"undefined\"\r\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\r\n      : false\r\n\r\n  if (prefersReducedMotion) {\r\n    step = text.length\r\n    chance = 0\r\n    overdrive = false\r\n  }\r\n\r\n  const nodeRef = React.useRef<any>(null)\r\n  const rafRef = React.useRef<number>(0)\r\n  const elapsedRef = React.useRef(0)\r\n  const fpsInterval = 1000 / (60 * speed)\r\n  const stepRef = React.useRef<number>(0)\r\n  const scrambleIndexRef = React.useRef<number>(0)\r\n  const controlRef = React.useRef<Array<string | number | null>>([])\r\n  const overdriveRef = React.useRef<number>(0)\r\n\r\n  const setIfNotIgnored = (\r\n    value: string | number | null,\r\n    replace: string | number | null\r\n  ) => (ignore.includes(`${value}`) ? value : replace)\r\n\r\n  const seedForward = () => {\r\n    if (scrambleIndexRef.current === text.length) return\r\n    for (let i = 0; i < seed; i++) {\r\n      const index = getRandomInt(\r\n        scrambleIndexRef.current,\r\n        controlRef.current.length\r\n      )\r\n      if (\r\n        typeof controlRef.current[index] !== \"number\" &&\r\n        typeof controlRef.current[index] !== \"undefined\"\r\n      ) {\r\n        controlRef.current[index] = setIfNotIgnored(\r\n          controlRef.current[index],\r\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const stepForward = () => {\r\n    for (let i = 0; i < step; i++) {\r\n      if (scrambleIndexRef.current < text.length) {\r\n        const currentIndex = scrambleIndexRef.current\r\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10\r\n        controlRef.current[currentIndex] = setIfNotIgnored(\r\n          text[scrambleIndexRef.current],\r\n          shouldScramble\r\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\r\n            : 0\r\n        )\r\n        scrambleIndexRef.current++\r\n      }\r\n    }\r\n  }\r\n\r\n  const resizeControl = () => {\r\n    if (text.length < controlRef.current.length) {\r\n      controlRef.current.pop()\r\n      controlRef.current.splice(text.length, step)\r\n    }\r\n    for (let i = 0; i < step; i++) {\r\n      if (controlRef.current.length < text.length) {\r\n        controlRef.current.push(\r\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const onOverdrive = () => {\r\n    if (!overdrive) return\r\n    for (let i = 0; i < step; i++) {\r\n      const max = Math.max(controlRef.current.length, text.length)\r\n      if (overdriveRef.current < max) {\r\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\r\n          text[overdriveRef.current],\r\n          String.fromCharCode(typeof overdrive === \"boolean\" ? 95 : overdrive)\r\n        )\r\n        overdriveRef.current++\r\n      }\r\n    }\r\n  }\r\n\r\n  const onTick = () => {\r\n    stepForward()\r\n    resizeControl()\r\n    seedForward()\r\n  }\r\n\r\n  /* eslint-disable react-hooks/exhaustive-deps */\r\n  const animate = (time: number) => {\r\n    if (!speed) return\r\n    rafRef.current = requestAnimationFrame(animate)\r\n    onOverdrive()\r\n    const timeElapsed = time - elapsedRef.current\r\n    if (timeElapsed > fpsInterval) {\r\n      elapsedRef.current = time\r\n      if (stepRef.current % tick === 0) {\r\n        onTick()\r\n      }\r\n      draw()\r\n    }\r\n  }\r\n\r\n  const draw = () => {\r\n    if (!nodeRef.current) return\r\n    let result = \"\"\r\n    for (let i = 0; i < controlRef.current.length; i++) {\r\n      const controlValue = controlRef.current[i]\r\n      switch (true) {\r\n        case typeof controlValue === \"number\" && controlValue > 0:\r\n          result += getRandomChar(range)\r\n          if (i <= scrambleIndexRef.current) {\r\n            controlRef.current[i] = (controlRef.current[i] as number) - 1\r\n          }\r\n          break\r\n        case typeof controlValue === \"string\" &&\r\n          (i >= text.length || i >= scrambleIndexRef.current):\r\n          result += controlValue\r\n          break\r\n        case controlValue === text[i] && i < scrambleIndexRef.current:\r\n          result += text[i]\r\n          break\r\n        case controlValue === 0 && i < text.length:\r\n          result += text[i]\r\n          controlRef.current[i] = text[i]\r\n          break\r\n        default:\r\n          result += \"\"\r\n      }\r\n    }\r\n    nodeRef.current.innerHTML = result\r\n    if (onAnimationFrame) {\r\n      onAnimationFrame(result)\r\n    }\r\n    if (result === text) {\r\n      controlRef.current.splice(text.length, controlRef.current.length)\r\n      if (onAnimationEnd) {\r\n        onAnimationEnd()\r\n      }\r\n      cancelAnimationFrame(rafRef.current)\r\n    }\r\n    stepRef.current++\r\n  }\r\n\r\n  const reset = () => {\r\n    stepRef.current = 0\r\n    scrambleIndexRef.current = 0\r\n    overdriveRef.current = 0\r\n    if (!overflow) {\r\n      controlRef.current = new Array(text.length)\r\n    }\r\n  }\r\n\r\n  const play = () => {\r\n    cancelAnimationFrame(rafRef.current)\r\n    reset()\r\n    if (onAnimationStart) {\r\n      onAnimationStart()\r\n    }\r\n    rafRef.current = requestAnimationFrame(animate)\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    reset()\r\n  }, [text])\r\n\r\n  React.useEffect(() => {\r\n    cancelAnimationFrame(rafRef.current)\r\n    rafRef.current = requestAnimationFrame(animate)\r\n    return () => {\r\n      cancelAnimationFrame(rafRef.current)\r\n    }\r\n  }, [animate])\r\n\r\n  React.useEffect(() => {\r\n    if (!playOnMount) {\r\n      controlRef.current = text.split(\"\")\r\n      stepRef.current = text.length\r\n      scrambleIndexRef.current = text.length\r\n      overdriveRef.current = text.length\r\n      draw()\r\n      cancelAnimationFrame(rafRef.current)\r\n    }\r\n  }, [])\r\n\r\n  return { ref: nodeRef, replay: play }\r\n}\r\n",
      "type": "registry:hook"
    }
  ]
}
