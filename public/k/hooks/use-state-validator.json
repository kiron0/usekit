{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-state-validator",
  "type": "registry:hook",
  "title": "Use State Validator",
  "description": "Validate state updates in React components with the useStateValidator hook, providing a way to ensure state changes meet specific criteria before being applied.",
  "files": [
    {
      "path": "registry/hooks/use-state-validator.ts",
      "content": "import * as React from \"react\"\nimport { z, ZodTypeAny } from \"zod\"\n\ntype Validator<T> = (\n  value: T\n) =>\n  | boolean\n  | string\n  | null\n  | undefined\n  | Promise<boolean | string | null | undefined>\ntype SchemaValidator<T> =\n  | ZodTypeAny\n  | ((value: T) => boolean | string | null | undefined)\n\ninterface Options<T> {\n  initialValue?: T | (() => T)\n  validator?: Validator<T> | SchemaValidator<T>\n  onInvalid?: (value: T, error: string) => void\n  onValid?: (value: T) => void\n  throwOnInvalid?: boolean\n  asyncDebounceMs?: number\n}\n\ninterface Result {\n  isValid: boolean\n  error?: string\n  isPending?: boolean\n}\n\nexport function useStateValidator<T>(\n  initialValue?: T | (() => T),\n  validator?: Validator<T> | SchemaValidator<T>,\n  options: Options<T> = {}\n): [T, React.Dispatch<React.SetStateAction<T>>, Result] {\n  const {\n    onInvalid,\n    onValid,\n    throwOnInvalid = false,\n    asyncDebounceMs = 300,\n  } = options\n\n  const validatorFn = React.useCallback(\n    (value: T): Promise<boolean | string | null | undefined> => {\n      if (!validator) return Promise.resolve(true)\n\n      try {\n        if (typeof (validator as z.ZodTypeAny)?.parse === \"function\") {\n          const result = (validator as z.ZodTypeAny).safeParse(value)\n          return Promise.resolve(\n            result.success\n              ? true\n              : result.error.errors[0]?.message || \"Invalid value\"\n          )\n        }\n        const result = (validator as Validator<T>)(value)\n        return Promise.resolve(result)\n      } catch (err) {\n        return Promise.resolve(\n          err instanceof Error ? err.message : \"Validation error\"\n        )\n      }\n    },\n    [validator]\n  )\n\n  const [state, setState] = React.useState<T>(initialValue as T)\n  const [validation, setValidation] = React.useState<Result>({\n    isValid: true,\n    isPending: false,\n  })\n  const validationTimeout = React.useRef<NodeJS.Timeout | null>(null)\n\n  React.useEffect(() => {\n    const validate = async () => {\n      try {\n        const result = await validatorFn(state)\n        const isValid = result === true\n        const error = typeof result === \"string\" ? result : undefined\n\n        setValidation({ isValid, error, isPending: false })\n        if (isValid) {\n          onValid?.(state)\n        } else {\n          onInvalid?.(state, error || \"Invalid value\")\n        }\n      } catch (err) {\n        console.error(\"Initial validation failed:\", err)\n      }\n    }\n\n    validate()\n  }, []) // eslint-disable-line react-hooks/exhaustive-deps\n\n  const safeSetState = React.useCallback<\n    React.Dispatch<React.SetStateAction<T>>\n  >(\n    async (value) => {\n      try {\n        const newValue =\n          typeof value === \"function\" ? (value as (prev: T) => T)(state) : value\n\n        setState(newValue)\n        setValidation((prev) => ({ ...prev, isPending: true }))\n\n        if (validationTimeout.current) {\n          clearTimeout(validationTimeout.current)\n        }\n\n        validationTimeout.current = setTimeout(async () => {\n          try {\n            const result = await validatorFn(newValue)\n            const isValid = result === true\n            const error = typeof result === \"string\" ? result : undefined\n\n            setValidation({ isValid, error, isPending: false })\n\n            if (isValid) {\n              onValid?.(newValue)\n            } else {\n              onInvalid?.(newValue, error || \"Invalid value\")\n              if (throwOnInvalid) {\n                throw new Error(error || \"Invalid state update\")\n              }\n            }\n          } catch (err) {\n            console.error(\"Validation failed:\", err)\n            setValidation({\n              isValid: false,\n              error: err instanceof Error ? err.message : \"Validation error\",\n              isPending: false,\n            })\n            if (throwOnInvalid) throw err\n          }\n        }, asyncDebounceMs)\n      } catch (err) {\n        console.error(\"State update failed:\", err)\n        if (throwOnInvalid) throw err\n      }\n    },\n    [state, validatorFn, onInvalid, onValid, throwOnInvalid, asyncDebounceMs]\n  )\n\n  React.useEffect(() => {\n    return () => {\n      if (validationTimeout.current) {\n        clearTimeout(validationTimeout.current)\n      }\n    }\n  }, [])\n\n  return [state, safeSetState, validation]\n}\n\nexport function useZodStateValidator<T>(\n  schema: ZodTypeAny,\n  options?: Omit<Options<T>, \"validator\">\n) {\n  return useStateValidator<T>(undefined, schema, options)\n}\n\nexport function useDebouncedStateValidator<T>(\n  validator: Validator<T>,\n  debounceMs: number = 300,\n  options?: Omit<Options<T>, \"validator\" | \"asyncDebounceMs\">\n) {\n  return useStateValidator<T>(undefined, validator, {\n    ...options,\n    asyncDebounceMs: debounceMs,\n  })\n}\n",
      "type": "registry:hook"
    }
  ]
}
