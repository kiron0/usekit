{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-measure-any",
  "type": "registry:hook",
  "title": "Use Any Measure",
  "description": "Measure the dimensions of any element with useMeasureAny, providing options to track changes and observe the element.",
  "dependencies": ["lucide-react"],
  "files": [
    {
      "path": "registry/hooks/use-measure-any.tsx",
      "content": "import * as React from \"react\"\nimport { Copy, RefreshCw } from \"lucide-react\"\nimport * as ReactDOM from \"react-dom\"\n\ntype Point = { x: number; y: number } | null\n\nconst convertPxTo = (px: number, unit: \"cm\" | \"rem\" | \"inches\") => {\n  const rem = px / 16\n  const inches = px / 96\n  const cm = inches * 2.54\n\n  return { cm, rem, inches }[unit]\n}\n\nconst MOBILE_BREAKPOINT = 768\n\ninterface MeasureOptions {\n  borderRadius?: number\n  borderWidth?: number\n  actionPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\n  measurementPosition?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n  startMeasure?: boolean\n  ref?: React.RefObject<HTMLDivElement | null>\n}\n\nconst actionPositions = [\n  { name: \"top-right\", top: 100, right: 16 },\n  { name: \"top-left\", top: 100, left: 16 },\n  { name: \"bottom-right\", bottom: 100, right: 16 },\n  { name: \"bottom-left\", bottom: 100, left: 16 },\n]\n\nconst measurementPositions = [\n  { name: \"top-right\", top: 16, right: 16 },\n  { name: \"top-left\", top: 16, left: 16 },\n  { name: \"bottom-right\", bottom: 16, right: 16 },\n  { name: \"bottom-left\", bottom: 16, left: 16 },\n]\n\nexport function useMeasureAny({\n  borderRadius = 0.5,\n  borderWidth = 1,\n  actionPosition = \"top-right\",\n  measurementPosition = \"bottom-left\",\n  startMeasure = false,\n  ref,\n}: MeasureOptions) {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  const [startPoint, setStartPoint] = React.useState<Point>(null)\n  const [endPoint, setEndPoint] = React.useState<Point>(null)\n  const [isMeasuring, setMeasuring] = React.useState(false)\n  const [isDragging, setDragging] = React.useState(false)\n  const [dragOffset, setDragOffset] = React.useState<{\n    x: number\n    y: number\n  } | null>(null)\n  const [resizeCorner, setResizeCorner] = React.useState<string | null>(null)\n  const borderBoxRef = React.useRef<HTMLDivElement>(null)\n\n  const originalStartRef = React.useRef<Point>(null)\n  const originalEndRef = React.useRef<Point>(null)\n  const initialMouseRef = React.useRef<{ x: number; y: number } | null>(null)\n\n  const getBoundingRect = React.useCallback(() => {\n    if (ref?.current) {\n      return ref.current.getBoundingClientRect()\n    }\n    return {\n      left: 0,\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      width: window.innerWidth,\n      height: window.innerHeight,\n    }\n  }, [ref])\n\n  const isMouseOverCorner = (\n    mouseX: number,\n    mouseY: number,\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n    threshold = 8\n  ) => {\n    const corners = [\n      { name: \"top-left\", x: left, y: top },\n      { name: \"top-right\", x: left + width, y: top },\n      { name: \"bottom-left\", x: left, y: top + height },\n      { name: \"bottom-right\", x: left + width, y: top + height },\n    ]\n\n    for (const corner of corners) {\n      const dx = Math.abs(mouseX - corner.x)\n      const dy = Math.abs(mouseY - corner.y)\n      if (dx < threshold && dy < threshold) return corner.name\n    }\n    return null\n  }\n\n  const handleMouseDown = React.useCallback(\n    (e: MouseEvent) => {\n      e.preventDefault()\n\n      if (ref?.current && !startMeasure) return\n\n      const rect = getBoundingRect()\n      const x = e.clientX - rect.left\n      const y = e.clientY - rect.top\n\n      if (ref?.current && !ref.current.contains(e.target as Node)) {\n        return\n      }\n\n      if (!startPoint || !endPoint) {\n        setStartPoint({ x, y })\n        setEndPoint({ x, y })\n        setMeasuring(true)\n        return\n      }\n\n      const left = Math.min(startPoint.x, endPoint.x)\n      const top = Math.min(startPoint.y, endPoint.y)\n      const width = Math.abs(endPoint.x - startPoint.x)\n      const height = Math.abs(endPoint.y - startPoint.y)\n\n      const corner = isMouseOverCorner(x, y, left, top, width, height)\n      if (corner) {\n        originalStartRef.current = startPoint\n        originalEndRef.current = endPoint\n        initialMouseRef.current = { x, y }\n        setResizeCorner(corner)\n      } else if (\n        x >= left &&\n        x <= left + width &&\n        y >= top &&\n        y <= top + height\n      ) {\n        setDragging(true)\n        setDragOffset({ x: x - left, y: y - top })\n      }\n    },\n    [startPoint, endPoint, getBoundingRect, ref, startMeasure]\n  )\n\n  const handleMouseMove = React.useCallback(\n    (e: MouseEvent) => {\n      if (ref?.current && !startMeasure) return\n\n      const rect = getBoundingRect()\n      const x = e.clientX - rect.left\n      const y = e.clientY - rect.top\n\n      if (isMeasuring) {\n        const constrainedX = Math.max(0, Math.min(x, rect.width))\n        const constrainedY = Math.max(0, Math.min(y, rect.height))\n        setEndPoint({ x: constrainedX, y: constrainedY })\n        return\n      }\n\n      if (\n        resizeCorner &&\n        originalStartRef.current &&\n        originalEndRef.current &&\n        initialMouseRef.current\n      ) {\n        const deltaX = x - initialMouseRef.current.x\n        const deltaY = y - initialMouseRef.current.y\n\n        const newStart = { ...originalStartRef.current }\n        const newEnd = { ...originalEndRef.current }\n\n        switch (resizeCorner) {\n          case \"top-left\":\n            newStart.x = Math.max(\n              0,\n              Math.min(newStart.x + deltaX, newEnd.x - 10)\n            )\n            newStart.y = Math.max(\n              0,\n              Math.min(newStart.y + deltaY, newEnd.y - 10)\n            )\n            break\n          case \"top-right\":\n            newEnd.x = Math.min(\n              getBoundingRect().width,\n              Math.max(newEnd.x + deltaX, newStart.x + 10)\n            )\n            newStart.y = Math.max(\n              0,\n              Math.min(newStart.y + deltaY, newEnd.y - 10)\n            )\n            break\n          case \"bottom-right\":\n            newEnd.x = Math.min(\n              getBoundingRect().width,\n              Math.max(newEnd.x + deltaX, newStart.x + 10)\n            )\n            newEnd.y = Math.min(\n              getBoundingRect().height,\n              Math.max(newEnd.y + deltaY, newStart.y + 10)\n            )\n            break\n          case \"bottom-left\":\n            newStart.x = Math.max(\n              0,\n              Math.min(newStart.x + deltaX, newEnd.x - 10)\n            )\n            newEnd.y = Math.min(\n              getBoundingRect().height,\n              Math.max(newEnd.y + deltaY, newStart.y + 10)\n            )\n            break\n          default:\n            break\n        }\n\n        if (newStart.x < newEnd.x && newStart.y < newEnd.y) {\n          setStartPoint(newStart)\n          setEndPoint(newEnd)\n        }\n      } else if (isDragging && dragOffset && startPoint && endPoint) {\n        const width = Math.abs(endPoint.x - startPoint.x)\n        const height = Math.abs(endPoint.y - startPoint.y)\n\n        const newLeft = Math.max(\n          0,\n          Math.min(x - dragOffset.x, getBoundingRect().width - width)\n        )\n        const newTop = Math.max(\n          0,\n          Math.min(y - dragOffset.y, getBoundingRect().height - height)\n        )\n\n        setStartPoint({ x: newLeft, y: newTop })\n        setEndPoint({ x: newLeft + width, y: newTop + height })\n      }\n    },\n    [\n      isMeasuring,\n      resizeCorner,\n      initialMouseRef,\n      startPoint,\n      endPoint,\n      dragOffset,\n      isDragging,\n      getBoundingRect,\n      ref,\n      startMeasure,\n    ]\n  )\n\n  const handleMouseUp = React.useCallback(() => {\n    setMeasuring(false)\n    setDragging(false)\n    setResizeCorner(null)\n    initialMouseRef.current = null\n    originalStartRef.current = null\n    originalEndRef.current = null\n  }, [])\n\n  React.useEffect(() => {\n    document.addEventListener(\"mousedown\", handleMouseDown)\n    document.addEventListener(\"mousemove\", handleMouseMove)\n    document.addEventListener(\"mouseup\", handleMouseUp)\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleMouseDown)\n      document.removeEventListener(\"mousemove\", handleMouseMove)\n      document.removeEventListener(\"mouseup\", handleMouseUp)\n    }\n  }, [handleMouseDown, handleMouseMove, handleMouseUp])\n\n  React.useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n      const onChange = () => {\n        setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n      }\n      mql.addEventListener(\"change\", onChange)\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n      return () => mql.removeEventListener(\"change\", onChange)\n    }\n  }, [])\n\n  const measurements = React.useMemo(() => {\n    if (!startPoint || !endPoint) return null\n\n    const widthPx = Math.abs(endPoint.x - startPoint.x)\n    const heightPx = Math.abs(endPoint.y - startPoint.y)\n\n    return {\n      width: {\n        px: widthPx,\n        cm: convertPxTo(widthPx, \"cm\"),\n        rem: convertPxTo(widthPx, \"rem\"),\n        inches: convertPxTo(widthPx, \"inches\"),\n      },\n      height: {\n        px: heightPx,\n        cm: convertPxTo(heightPx, \"cm\"),\n        rem: convertPxTo(heightPx, \"rem\"),\n        inches: convertPxTo(heightPx, \"inches\"),\n      },\n    }\n  }, [startPoint, endPoint])\n\n  const MeasureComponent = () => {\n    React.useEffect(() => {\n      const borderBox = borderBoxRef.current\n      if (!borderBox || !startPoint || !endPoint) return\n\n      const handleMouseMove = (e: MouseEvent) => {\n        const rect = borderBox.getBoundingClientRect()\n        const mouseX = e.clientX - rect.left\n        const mouseY = e.clientY - rect.top\n        const threshold = 8\n\n        const corners = [\n          { name: \"top-left\", x: 0, y: 0 },\n          { name: \"top-right\", x: rect.width, y: 0 },\n          { name: \"bottom-left\", x: 0, y: rect.height },\n          { name: \"bottom-right\", x: rect.width, y: rect.height },\n        ]\n\n        let cursor = \"move\"\n        for (const corner of corners) {\n          const dx = Math.abs(mouseX - corner.x)\n          const dy = Math.abs(mouseY - corner.y)\n          if (dx < threshold && dy < threshold) {\n            if (corner.name === \"top-left\" || corner.name === \"bottom-right\") {\n              cursor = \"nwse-resize\"\n            } else if (\n              corner.name === \"top-right\" ||\n              corner.name === \"bottom-left\"\n            ) {\n              cursor = \"nesw-resize\"\n            }\n            break\n          }\n        }\n\n        borderBox.style.cursor = cursor\n      }\n\n      borderBox.addEventListener(\"mousemove\", handleMouseMove)\n      return () => borderBox.removeEventListener(\"mousemove\", handleMouseMove)\n    }, [])\n\n    if (!startPoint || !endPoint || (ref?.current && !startMeasure) || isMobile)\n      return null\n\n    const rect = getBoundingRect()\n    const left = Math.min(startPoint.x, endPoint.x) + rect.left\n    const top = Math.min(startPoint.y, endPoint.y) + rect.top\n    const width = Math.abs(endPoint.x - startPoint.x)\n    const height = Math.abs(endPoint.y - startPoint.y)\n\n    const handleReset = () => {\n      setStartPoint(null)\n      setEndPoint(null)\n    }\n\n    const handleCopy = async () => {\n      if (measurements) {\n        const text = `Width: ${measurements.width.px.toFixed(1)}px, Height: ${measurements.height.px.toFixed(1)}px`\n        await navigator.clipboard.writeText(text)\n      }\n    }\n\n    return ReactDOM.createPortal(\n      <>\n        <div\n          ref={borderBoxRef}\n          style={{\n            position: \"fixed\",\n            left,\n            top,\n            width,\n            height,\n            borderRadius: `${borderRadius}px`,\n            borderWidth: `${borderWidth}px`,\n          }}\n          className=\"fixed z-[48] border border-dashed border-primary bg-transparent md:z-[998]\"\n        />\n        <div\n          style={{\n            ...measurementPositions.find(\n              (pos) => pos.name === measurementPosition\n            ),\n          }}\n          className=\"pointer-events-none fixed z-[49] rounded-md border bg-background/50 p-4 text-sm backdrop-blur md:z-[999]\"\n        >\n          <div className=\"flex flex-col gap-1\">\n            <span>\n              Width: {measurements?.width.px?.toFixed(0)} px (\n              {measurements?.width.cm?.toFixed(1)} cm,{\" \"}\n              {measurements?.width.rem?.toFixed(1)} rem,{\" \"}\n              {measurements?.width.inches?.toFixed(1)} inches)\n            </span>\n            <span>\n              Height: {measurements?.height.px?.toFixed(0)} px (\n              {measurements?.height.cm?.toFixed(1)} cm,{\" \"}\n              {measurements?.height.rem?.toFixed(1)} rem,{\" \"}\n              {measurements?.height.inches?.toFixed(1)} inches)\n            </span>\n          </div>\n        </div>\n\n        <div\n          style={{\n            ...actionPositions.find((pos) => pos.name === actionPosition),\n          }}\n          className=\"fixed z-[999] flex gap-2\"\n        >\n          <button\n            className=\"h-8 rounded-md bg-primary px-3 text-xs text-primary-foreground\"\n            onClick={handleReset}\n          >\n            <RefreshCw size={16} />\n          </button>\n          <button\n            className=\"h-8 rounded-md bg-primary px-3 text-xs text-primary-foreground\"\n            onClick={handleCopy}\n          >\n            <Copy size={16} />\n          </button>\n        </div>\n      </>,\n      ref?.current || document.body\n    )\n  }\n\n  if (isMobile || (ref?.current && !startMeasure)) {\n    return {\n      isMobile,\n      measurements: {},\n      MeasureComponent: () => null,\n      reset: () => {},\n    }\n  } else {\n    return {\n      isMobile,\n      measurements,\n      MeasureComponent,\n      reset: () => {\n        setStartPoint(null)\n        setEndPoint(null)\n      },\n    }\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}
